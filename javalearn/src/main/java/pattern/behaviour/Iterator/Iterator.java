package pattern.behaviour.Iterator;

/**
 * 迭代器 ，该接口提供了迭代遍历的通用方法
 * Iterator迭代器模式，提供一种统一的方法访问一个容器（Container）对象中各个元素，而又不需暴露该对象的内部细节，迭代器模式是为容器而设计。
 * 程序对容器对象的访问必然涉及到遍历算法，不同的容器遍历算法是不同的，List，Stack和Set等等常用容器遍历元素的算法各不相同。
 * 解决容器遍历算法差异有两种方案：第一，可以将遍历方法塞到容器对象中去，容器承受了过多的功能，它不仅要负责自己“容器”内的元素维护（添加、删除等等），
 * 而且还要提供遍历自身的接口；第二，根本不提供容器遍历算法，让容器使用者自己去实现。该方法虽然是省事，却又将容器的内部细节暴露无遗。
 * 迭代器模式的出现，很好的解决了上面两种情况的弊端，不但将遍历容器的算法从不同集合容器类中抽象出来，同时又对外隐藏了容器的具体实现细节。
 * 迭代器模式由以下角色组成： 1) 迭代器角色（Iterator）：迭代器角色负责定义访问和遍历元素的接口。 2) 具体迭代器角色（Concrete
 * Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。 3)
 * 容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。 4) 具体容器角色（Concrete
 * Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。
 * 
 * @author Peng.lv
 *
 */

public interface Iterator {
	boolean hasNext();

	Object next();

	void remove();
}
